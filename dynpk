#!/bin/env python
# Copyright 2010 Robert Spanton <rspanton@zepler.net>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
import os, sys, subprocess, shutil, stat, entities
from entities import Elf, InstalledRpm, get_elf_libs

if len(sys.argv) < 3:
    print "Usage: %s output-dir exec1 [exec2 ...]" % (os.path.basename(sys.argv[0]))
    sys.exit(1)

DIRN = sys.argv[1]
fnames = sys.argv[2:]

if os.path.exists(DIRN):
    print "Target directory \"%s\" already exists." % DIRN
    print "Cowardly refusing to overwrite it."
    sys.exit(1)

os.makedirs( DIRN )
BINDIR = os.path.join( DIRN, "bin" )
os.mkdir( BINDIR )
LIBDIR = os.path.join( DIRN, "lib" )
os.mkdir( LIBDIR )

# Dynamic linker:
shutil.copy( "/lib/ld-linux.so.2", LIBDIR )
# Auditor:
script_dir = os.path.dirname( os.path.abspath(__file__) )
shutil.copy( os.path.join( script_dir, "libaudit.so" ), LIBDIR )

# Fakechroot
FAKEROOT_LIB="/usr/lib/fakechroot/libfakechroot.so"
if not os.path.exists( FAKEROOT_LIB ):
    print "Error: libfakechroot.so not found on your system."
    print "You need to install it."
    print "On Fedora, it's in the fakechroot-libs package."
    print "Or you can download it from http://fakechroot.alioth.debian.org/"
    sys.exit(1)

shutil.copy( FAKEROOT_LIB , LIBDIR )

ents = []
files = set()

for fname in fnames:
    if fname[:4] == "rpm(":
        ent = InstalledRpm(fname[4:-1])
    else:
        ent = Elf(fname)
    ents.append(ent)

    for f in ent.get_files():
        files.add(f)

    ent.add_extras(DIRN)

for f in files:
    dest = os.path.join( DIRN, f.dest )

    destdir = os.path.dirname(dest)
    if not os.path.isdir( destdir ):
        os.makedirs( destdir )

    if os.path.isdir(f.source):
        if not os.path.exists(dest):
            os.makedirs(dest)
    else:
        try:
            shutil.copy( f.source, dest )
        except IOError:
            print "Warning: Couldn't read \"%s\" -- ignoring." % f.source

    if f.perms != None:
        os.chmod( dest, f.perms )

def is_elf(path):
    f = subprocess.Popen( "file -b %s" % path,
                          shell = True,
                          stdout = subprocess.PIPE )
    so, se = f.communicate()
    assert( f.wait() == 0 )

    if "ELF" in so and "executable" in so:
        if "statically" in so:
            print "Warning: \"%s\" is statically linked" % path
            return False

        return True
    return False

def write_wrapper(wrapper_path):
    shutil.copy( os.path.join( script_dir, "wrap" ), wrapper_path )

def wrap_binary(path):
    assert( path[:len(DIRN)] == DIRN )
    abspath = path[len(DIRN):]

    # Move the binary into /wrap${abspath}
    wrap_dir = os.path.join( DIRN, "wrap" )
    wrap_dir = "%s%s" % (wrap_dir, os.path.dirname(abspath))

    if not os.path.exists(wrap_dir):
        os.makedirs(wrap_dir)

    shutil.move(path, wrap_dir)
    write_wrapper( path )

def proc_dir(arg, dirname, names):
    assert "/wrap" not in dirname

    for name in names:
        fullpath = os.path.join(dirname, name)

        if is_elf( fullpath ):
            # Add any missing libraries:
            for lib in get_elf_libs(fullpath):
                libp = "%s%s" % (DIRN, lib)

                libdir = os.path.dirname(libp)
                if not os.path.exists(libdir):
                    os.makedirs(libdir)

                if not os.path.exists(libp):
                    shutil.copy(lib, libp)

            # Wrap it up!
            wrap_binary(fullpath)

# Now iterate through all files, and wrap executable elves up in 
# a blanket of fakechroot
os.path.walk( DIRN, proc_dir, None )

# Write the script to climb inside the fakechroot
fake_script = os.path.join( DIRN, "fake" )
f = open( fake_script, "w" )
f.write( """#!/bin/bash

SCRIPT_DIR="${BASH_SOURCE[0]}";
if([ -h "${SCRIPT_DIR}" ]) then
  while([ -h "${SCRIPT_DIR}" ]) do SCRIPT_DIR=`readlink "${SCRIPT_DIR}"`; done
fi
pushd . > /dev/null
cd `dirname ${SCRIPT_DIR}` > /dev/null
SCRIPT_DIR=`pwd`;
popd  > /dev/null

export LD_LIBRARY_PATH=$SCRIPT_DIR/lib:$SCRIPT_DIR/usr/lib

# Fakeroot config
export FAKECHROOT_BASE=$SCRIPT_DIR
export LD_PRELOAD=libfakechroot.so
#export FAKECHROOT_EXCLUDE_PATH=/home:/bin

# Auditing
#export AUDIT_PREFIX=$SCRIPT_DIR
#export LD_AUDIT=libaudit.so

export PATH=/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin

export PS1='[FAKECHROOT@\h \W]\$ '

# Hand over
exec $SCRIPT_DIR/$@
""")
f.close()
os.chmod( fake_script, stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR )

conf_fname = os.path.join( DIRN, "dynpk.config" )
f = open( conf_fname, "w" )
f.write( """#File automatically made by dynpk

# Fakechroot stuff
FAKECHROOT_BASE=$FAKECHROOT_BASE
LD_PRELOAD=libfakechroot.so
#FAKECHROOT_EXCLUDE_PATH=/home:/bin

LD_LIBRARY_PATH=$FAKECHROOT_BASE/lib:$FAKECHROOT_BASE/usr/lib
PATH=/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin

# Auditing
#AUDIT_PREFIX=$FAKECHROOT_BASE
#LD_AUDIT=libaudit.so

PS1=[FAKECHROOT@\h \W]\$ 
""" )
f.close()

f = open( os.path.join( DIRN, ".fakechroot-base" ), "w" )
f.write("Base of fakeroot tree");
f.close()
