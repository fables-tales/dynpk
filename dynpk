#!/bin/env python
# Copyright 2010 Robert Spanton <rspanton@zepler.net>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
import os, sys, subprocess, re, shutil, stat

if len(sys.argv) < 3:
    print "Usage: %s output-dir exec1 [exec2 ...]" % (os.path.basename(sys.argv[0]))
    sys.exit(1)

class File:
    def __init__(self, source, dest, perms = None):
        self.source = source
        self.dest = dest
        self.perms = perms

    def __hash__(self):
        s = "%s %s %s" % (self.source, self.dest, str(self.perms))
        return s.__hash__()

    def __eq__(self, other):
        if ( self.source != other.source or
             self.dest != other.dest or
             self.perms != other.perms ):
            return False
        return True

class Entity:
    def __init__(self):
        pass

def get_elf_libs(fname):
    p = subprocess.Popen("ldd %s | grep '=>'" % fname,
                         shell = True,
                         stdout = subprocess.PIPE,
                         stderr = subprocess.PIPE)
    so, se = p.communicate()
    if p.wait() != 0:
        print se
        print "ERRROR: ldd \"%s\" failed -- aborting" % fname
        sys.exit(1)

    return re.findall( "/[^ ]+", so )

class Elf(Entity):
    def __init__(self, fname):
        self.fname = fname
        Entity.__init__(self)

    def _get_libs(self):
        return get_elf_libs(self.fname)

    def get_files(self):
        files = []

        for lib in self._get_libs():
            files.append( File( lib, lib[1:] ) )

        files.append( File( self.fname,
                            "bin/%s" % os.path.basename(self.fname),
                            perms = stat.S_IRUSR | stat.S_IWUSR ) )
        return files


    def add_extras(self, basedir):
        self._write_wrapper( os.path.join( basedir,
                                           "bin",
                                           os.path.basename(self.fname) ) )

class InstalledRpm(Entity):
    def __init__(self, pkgname):
        self.pkgname = pkgname
        Entity.__init__(self)

    def get_files(self):
        p = subprocess.Popen( "rpm -ql %s" % self.pkgname,
                              stdout = subprocess.PIPE, shell = True)
        so, se = p.communicate()
        assert( p.wait() == 0 )

        files = []
        for x in so.splitlines():
            files.append( File( x, x[1:] ) )
        return files

    def add_extras(self, basedir):
        pass

DIRN = sys.argv[1]
fnames = sys.argv[2:]

if os.path.exists(DIRN):
    print "Target directory \"%s\" already exists." % DIRN
    print "Cowardly refusing to overwrite it."
    sys.exit(1)

os.makedirs( DIRN )
BINDIR = os.path.join( DIRN, "bin" )
os.mkdir( BINDIR )
LIBDIR = os.path.join( DIRN, "lib" )
os.mkdir( LIBDIR )

# Dynamic linker:
shutil.copy( "/lib/ld-linux.so.2", LIBDIR )
# Auditor:
script_dir = os.path.dirname( os.path.abspath(__file__) )
shutil.copy( os.path.join( script_dir, "libaudit.so" ), LIBDIR )
# Fakechroot
shutil.copy( "/usr/lib/fakechroot/libfakechroot.so", LIBDIR )

ents = []
files = set()

for fname in fnames:
    if fname[:4] == "rpm(":
        ent = InstalledRpm(fname[4:-1])
    else:
        ent = Elf(fname)
    ents.append(ent)

    for f in ent.get_files():
        files.add(f)

    ent.add_extras(DIRN)

for f in files:
    dest = os.path.join( DIRN, f.dest )

    destdir = os.path.dirname(dest)
    if not os.path.isdir( destdir ):
        os.makedirs( destdir )

    if os.path.isdir(f.source):
        if not os.path.exists(dest):
            os.makedirs(dest)
    else:
        try:
            shutil.copy( f.source, dest )
        except IOError:
            print "Warning: Couldn't read \"%s\" -- ignoring." % f.source

    if f.perms != None:
        os.chmod( dest, f.perms )

def is_elf(path):
    f = subprocess.Popen( "file -b %s" % path,
                          shell = True,
                          stdout = subprocess.PIPE )
    so, se = f.communicate()
    assert( f.wait() == 0 )

    if "ELF" in so and "executable" in so:
        if "statically" in so:
            print "Warning: \"%s\" is statically linked" % path
            return False

        return True
    return False

def write_wrapper(wrapper_path):
    shutil.copy( os.path.join( script_dir, "wrap" ), wrapper_path )

def wrap_binary(path):
    assert( path[:len(DIRN)] == DIRN )
    abspath = path[len(DIRN):]

    # Move the binary into /wrap${abspath}
    wrap_dir = os.path.join( DIRN, "wrap" )
    wrap_dir = "%s%s" % (wrap_dir, os.path.dirname(abspath))

    if not os.path.exists(wrap_dir):
        os.makedirs(wrap_dir)

    shutil.move(path, wrap_dir)
    write_wrapper( path )

def proc_dir(arg, dirname, names):
    assert "/wrap" not in dirname

    for name in names:
        fullpath = os.path.join(dirname, name)

        if is_elf( fullpath ):
            # Add any missing libraries:
            for lib in get_elf_libs(fullpath):
                libp = "%s%s" % (DIRN, lib)

                libdir = os.path.dirname(libp)
                if not os.path.exists(libdir):
                    os.makedirs(libdir)

                if not os.path.exists(libp):
                    shutil.copy(lib, libp)

            # Wrap it up!
            wrap_binary(fullpath)

# Now iterate through all files, and wrap executable elves up in 
# a blanket of fakechroot
os.path.walk( DIRN, proc_dir, None )

# Write the script to climb inside the fakechroot
fake_script = os.path.join( DIRN, "fake" )
f = open( fake_script, "w" )
f.write( """#!/bin/bash

SCRIPT_DIR="${BASH_SOURCE[0]}";
if([ -h "${SCRIPT_DIR}" ]) then
  while([ -h "${SCRIPT_DIR}" ]) do SCRIPT_DIR=`readlink "${SCRIPT_DIR}"`; done
fi
pushd . > /dev/null
cd `dirname ${SCRIPT_DIR}` > /dev/null
SCRIPT_DIR=`pwd`;
popd  > /dev/null

export LD_LIBRARY_PATH=$SCRIPT_DIR/lib:$SCRIPT_DIR/usr/lib

# Fakeroot config
export FAKECHROOT_BASE=$SCRIPT_DIR
export LD_PRELOAD=libfakechroot.so
#export FAKECHROOT_EXCLUDE_PATH=/home:/bin

# Auditing
#export AUDIT_PREFIX=$SCRIPT_DIR
#export LD_AUDIT=libaudit.so

export PATH=/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin

export PS1='[FAKECHROOT@\h \W]\$ '

# Hand over
exec $SCRIPT_DIR/$@
""")
f.close()
os.chmod( fake_script, stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR )
