#!/bin/env python
# Copyright 2010 Robert Spanton <rspanton@zepler.net>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
import os, sys, subprocess, re, shutil, stat

if len(sys.argv) < 3:
    print "Usage: %s output-dir exec1 [exec2 ...]" % (os.path.basename(sys.argv[0]))
    sys.exit(1)

class File:
    def __init__(self, source, dest, perms = None):
        self.source = source
        self.dest = dest
        self.perms = perms

    def __hash__(self):
        s = "%s %s %s" % (self.source, self.dest, str(self.perms))
        return s.__hash__()

    def __eq__(self, other):
        if ( self.source != other.source or
             self.dest != other.dest or
             self.perms != other.perms ):
            return False
        return True

class Entity:
    def __init__(self):
        pass

class Elf(Entity):
    def __init__(self, fname):
        self.fname = fname
        Entity.__init__(self)

    def _get_libs(self):
        p = subprocess.Popen("ldd %s | grep '=>'" % self.fname,
                             shell = True,
                             stdout = subprocess.PIPE)
        so, se = p.communicate()
        assert p.wait() == 0

        return re.findall( "/[^ ]+", so )

    def get_files(self):
        files = []

        for lib in self._get_libs():
            files.append( File( lib, os.path.basename(lib) ) )

        files.append( File( self.fname,
                            os.path.basename(self.fname),
                            perms = stat.S_IRUSR | stat.S_IWUSR ) )
        return files


    def add_extras(self, basedir):
        self._write_wrapper( os.path.join( basedir,
                                           "bin",
                                           os.path.basename(self.fname) ) )

class InstalledRpm(Entity):
    def __init__(self, pkgname):
        self.pkgname = pkgname
        Entity.__init__(self)

    def get_files(self):
        p = subprocess.Popen( "rpm -ql %s" % self.pkgname,
                              stdout = subprocess.PIPE, shell = True)
        so, se = p.communicate()
        assert( p.wait() == 0 )

        files = []
        for x in so.splitlines():
            files.append( File( x, x[1:] ) )
        return files

    def add_extras(self, basedir):
        pass

DIRN = sys.argv[1]
fnames = sys.argv[2:]

if os.path.exists(DIRN):
    print "Target directory \"%s\" already exists." % DIRN
    print "Cowardly refusing to overwrite it."
    sys.exit(1)

os.makedirs( DIRN )
BINDIR = os.path.join( DIRN, "bin" )
os.mkdir( BINDIR )
LIBDIR = os.path.join( DIRN, "lib" )
os.mkdir( LIBDIR )

# Dynamic linker:
shutil.copy( "/lib/ld-linux.so.2", LIBDIR )
# Auditor:
script_dir = os.path.dirname( os.path.abspath(__file__) )
shutil.copy( os.path.join( script_dir, "libaudit.so" ), LIBDIR )
# Fakechroot
shutil.copy( "/usr/lib/fakechroot/libfakechroot.so", LIBDIR )

ents = []
files = set()

for fname in fnames:
    if fname[:4] == "rpm(":
        ent = InstalledRpm(fname[4:-1])
    else:
        ent = Elf(fname)
    ents.append(ent)

    for f in ent.get_files():
        files.add(f)

    ent.add_extras(DIRN)

for f in files:
    dest = os.path.join( DIRN, f.dest )

    destdir = os.path.dirname(dest)
    if not os.path.isdir( destdir ):
        os.makedirs( destdir )

    shutil.copy( f.source, dest )

    if f.perms != None:
        os.chmod( dest, f.perms )

def is_elf(path):
    f = subprocess.Popen( "file -b %s" % path,
                          shell = True,
                          stdout = subprocess.PIPE )
    so, se = f.communicate()
    assert( f.wait() == 0 )

    if "ELF" in so and "executable" in so:
        return True
    return False

def write_wrapper(wrapper_path, target):
    f = open( wrapper_name , "w" )
    f.write( """#!/bin/bash

export AUDIT_PREFIX=$FAKEROOT_BASE
export LD_AUDIT=libaudit.so
export LD_LIBRARY_PATH=$FAKEROOT_BASE/lib

exec /lib/ld-linux.so.2 $FAKEROOT_BASE/%s $@
""" % os.path.basename(target) )
    f.close()

    # Add executable permissions
    os.chmod( wrapper_name, stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR )

def wrap_binary(path):
    assert( path[:len(DIRN)] == DIRN )
    abspath = path[len(DIRN):]

    # Move the binary into /wrap${abspath}
    wrap_dir = os.path.join( DIRN, "wrap" )
    wrap_dir = "%s%s" % (wrap_dir, os.path.dirname(abspath))

    if not os.path.exists(wrap_dir):
        os.makedirs(wrap_dir)

    shutil.move(path, wrap_dir)
    write_wrapper( path, "%s%s" % ("/wrap", abspath) )

def proc_dir(arg, dirname, names):
    for name in names:
        fullpath = os.path.join(dirname, name)

        if is_elf( fullpath ):
            # Wrap it up!
            wrap_binary(fullpath)

# Now iterate through all files, and wrap executable elves up in 
# a blanket of fakechroot
os.path.walk( DIRN, proc_dir, None )

# Write the script to climb inside the fakechroot
fake_script = os.path.join( DIRN, "fake" )
f = open( fake_script, "w" )
f.write( """#!/bin/bash

SCRIPT_DIR="${BASH_SOURCE[0]}";
if([ -h "${SCRIPT_DIR}" ]) then
  while([ -h "${SCRIPT_DIR}" ]) do SCRIPT_DIR=`readlink "${SCRIPT_DIR}"`; done
fi
pushd . > /dev/null
cd `dirname ${SCRIPT_DIR}` > /dev/null
SCRIPT_DIR=`pwd`;
popd  > /dev/null

echo fakechroot base: $SCRIPT_DIR

export FAKECHROOT_BASE=$SCRIPT_DIR
#export FAKECHROOT_EXCLUDE_PATH=/home:/bin
export LD_PRELOAD=$SCRIPT_DIR/lib/libfakechroot.so
export LD_LIBRARY_PATH=$SCRIPT_DIR/lib

exec $SCRIPT_DIR/lib/ld-linux.so.2 $SCRIPT_DIR/$@
""")
f.close()
os.chmod( fake_script, stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR )
